- [Виды тестирования](#types)
- [Уровни тестирования](#levels)
- [Модульное тестирование](#units)
  - [Для чего нужны тесты](#units__need)
  - [Когда тесты не нужны](#units__redundant)
  - [Инструменты для тестирования](#units__tools)
  - [Behavior Driven Development (BDD)](#units__bdd)
  - [Спецификация](#units__specification)


# <a name="types"></a>  Виды тестирования


- **Статическое** — без запуска программы. Главным образом это проверка проектной документации и спецификации
- **Динамическое** — программу запускают и проверяют, как она ведёт себя во время работы
---
- **Функциональное** — проверяют, как программа решает задачи, нужные клиенту
- **Нефункциональное** — исследуют производительность системы, её надёжность и защищённость, работу с окружением — операционной системой и оборудованием
---
- **Черный ящик** — проверяют поведение и производительность программы взаимодействуя с программным интерфейсом без доступа к исходному коду
- **Белый ящик** — исследуют структуру и логику всей программы или отдельных её компонент с доступом к исходному коду
---
- **Ручное** — работу проверяют вручную, без использования программных средств
- **Aвтоматическое** — применяют специально написанные автоматические тесты, которые постоянно обновляют

# <a name="levels"></a>  Уровни тестирования

1. **Модульное тестирование** делается в самом начале, когда готовы те куски кода, которые можно проверить по отдельности: объекты, классы, функции, программные модули. Тесты пишутся отдельно для каждой функции или метода. На этом этапе проверяют работоспособность части кода, нет ли регрессии — не появились ли после изменения кода ошибки там, где раньше всё работало нормально. Это самый нижний уровень тестирования, часто это делают те, кто пишет код

1. К **интеграционному тестированию** переходят после модульной проверки. Здесь тестируют связи между проверенными элементами и то, как программа взаимодействует с операционной системой, оборудованием

1. **Системное тестирование** показывает, соответствует ли готовая система функциональным и нефункциональным требованиям

1. **Приёмочное тестирование** проходит, когда заказчик принимает приложения от разработчиков. Его цель — убедиться, что продукт удовлетворяет требованиям клиента. На основании этого покупатель решает, готова ли программа или её нужно дорабатывать


# <a name="units"></a> Модульное тестирование
## <a name="units__need"></a>    Для чего нужны тесты

### Поощрение изменений
Модульное тестирование позже позволяет программистам проводить рефакторинг, будучи уверенными, что модуль по-прежнему работает корректно (регрессионное тестирование). Это поощряет программистов к изменениям кода, поскольку достаточно легко проверить, что код работает и после изменений

### Упрощение интеграции
Модульное тестирование помогает устранить сомнения по поводу отдельных модулей и может быть использовано для подхода к тестированию «снизу вверх»: сначала тестируя отдельные части программы, а затем программу в целом

### Документирование кода
Модульные тесты можно рассматривать как «живой документ» для тестируемого класса. Клиенты, которые не знают, как использовать данный класс, могут использовать юнит-тест в качестве примера

### Отделение интерфейса от реализации
Поскольку некоторые классы могут использовать другие классы, тестирование отдельного класса часто распространяется на связанные с ним. Например, класс пользуется базой данных; в ходе написания теста программист обнаруживает, что тесту приходится взаимодействовать с базой. Это ошибка, поскольку тест не должен выходить за границу класса. В результате разработчик абстрагируется от соединения с базой данных и реализует этот интерфейс, используя свой собственный mock-объект. Это приводит к менее связанному коду, минимизируя зависимости в системе






---


## <a name="units__redundant"></a> Когда тесты не нужны

- Вы делаете простой сайт-визитку из 5 статических html-страниц и с одной формой отправки письма. На этом заказчик, скорее всего, успокоится, ничего большего ему не нужно. Здесь нет никакой особенной логики, быстрее просто все проверить «руками»
- Вы занимаетесь рекламным сайтом/простыми флеш-играми или баннерами – сложная верстка/анимация или большой объем статики. Никакой логики нет, только представление
- Вы делаете проект для выставки. Срок – от двух недель до месяца, ваша система – комбинация железа и софта, в начале проекта не до конца известно, что именно должно получиться в конце. Софт будет работать 1-2 дня на выставке
- Вы всегда пишете код без ошибок, обладаете идеальной памятью и даром предвидения. Ваш код настолько крут, что изменяет себя сам, вслед за требованиями клиента. Иногда код объясняет клиенту, что его требования — гов не нужно реализовывать


## <a name="units__tools"></a> Инструменты для тестирования

- Unit.js — фреймворк или библиотека утверждений для JS, которая работает как в браузере, так и в Node.js
- Mocha — многофункциональная среда тестирования JavaScript, которая применяется для асинхронного тестирования
- Jasmine — среда с чистым синтаксисом. Применяется для написания тестов без применения DOM
- Karma — среда для запуска тестов на реальных устройствах
- Jest — простой фреймворк для тестирования JavaScript. Не требует дополнительных настроек конфигураций и загрузки библиотек
- AVA — среда модульного тестирования и выполнения тестов в Node.js
- QUnit — универсальный фреймворк для проведения тестов в браузере, Node.js и даже внутри Web Worker





## <a name="units__bdd"></a> Behavior Driven Development (BDD)
**BDD** – это три в одном: и тесты, и документация, и примеры использования.

Процесс разработки:
1. Пишется начальная спецификация с тестами, проверяющими основную функциональность
2. Создаётся начальная реализация
3. Запускаем тесты. Пока функция не готова, будут ошибки. Вносим изменения до тех пор, пока всё не начнёт работать так, как нужно
4. Теперь есть правильно работающая начальная реализация и тесты
5. Добавляем новые способы использования в спецификацию, возможно, ещё не реализованные в тестируемом коде. Тесты начинают «падать» (выдавать ошибки)
6. Возвращаемся на шаг 3, дописываем реализацию до тех пор, пока тесты не начнут завершаться без ошибок
1. Повторяем шаги 3-6, пока требуемая функциональность не будет готова

## <a name="units__specification"></a> Спецификация
**Спецификация** — описание работы модуля

```
describe("pow", function() {

  it("возводит в степень n", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

Спецификация состоит из трёх основных блоков:
- `describe("заголовок", function() { ... })` —
Какую функциональность мы описываем
- `it("описание", function() { ... })` —
В первом аргументе блока `it` мы человеческим языком описываем конкретный способ использования функции, а во втором – пишем функцию, которая тестирует данный случай
- `assert.equal(value1, value2)` —
Код внутри блока it, если функция работает верно, должен выполняться без ошибок.
Функции вида assert.* используются для проверки того, что функция pow работает так, как мы ожидаем. В этом примере мы используем одну из них – assert.equal, которая сравнивает переданные значения и выбрасывает ошибку, если они не равны друг другу. Существуют и другие типы сравнений и проверок, которые мы добавим позже.

## <a name="units__syntax"></a> Синтаксис

### Генерация тестов через цикл
### Вложенные блоки `describe`
### `before/after` и `beforeEach/afterEach`
### Функции сравнения [Assert](https://www.chaijs.com/api/assert/)

# Источники:


[Что такое тестирование программ и зачем оно нужно](https://skillbox.ru/media/code/chto_takoe_testirovanie_programm/)

[Модульное тестирование](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5s)

[Юнит-тесты в JavaScript: инструменты и платформы](https://highload.today/yunit-testy-v-javascript-instrumenty-i-platformy/)

[https://learn.javascript.ru/testing-mocha#behavior-driven-development-bdd](https://learn.javascript.ru/testing-mocha#behavior-driven-development-bdd)

[Chai Assertion Library](https://www.chaijs.com/api/assert/)